
사용자 등록, 수정화면

1. 사용자ID
2. 사용자명
3. 사용자영문명
4. 사용여부
5. 사용자등록일
6. 최초등록일시
7. 최종수정일시


ctrl+shift+R 강력새로고침

------------------------------
# 코드리뷰
1=1 대신 삭제여부로 조건

로우넘버오버 파티션바이

유저키검색하는 조건문 (나중에 힌트가될수있다)

rest api 를 생각하자 

화면 넘어갈때도 검색조건 유지시키기


그리드 필드는 쉽게 이해하면 자바의 dto
데이터타입이 텍스트만 있는게 아니다

그리드.데이터프로바이더 변수에 바인딩
데이트프로바이더에 셋 필드 해서 필드를 세팅하고
그리드.그리드뷰 변수에 바인딩
그리드.그리드뷰에 셋데이터소스

컬럼에 대한 정보를 정의해야한다
에딧터블 수정가능한지아닌지
스타일 : 스타일정의

그리드뷰에 셋컬럼
그리드뷰.디스플레이옵션 = 블록 혹은 싱글로우 등으로 하면 드래그가 한줄씩 된다든가

리얼그리드홈페이지에서 다 찾아보자

bind(this)를 해야 안에서 this를 쓸수있는경우 있다

select해서 데이터를 가져오고
grid.gridView.refresh() 를 해야 업데이트가된다

reset 메서드의 
this.grid.gridView.commit() 은 뭔가?
이것을 해야 데이터프로바이더에도 수정이 된다. 아니면 기존 데이터로 가기때문에


컨트롤러에는 save 하나만 추가하면된다.

key(route) {
      return `/bbs/noti/${route.params.catalog}`
},
이런식으로 키를 meta 에 속성으로 세팅하면
같은값이라면 위에 메뉴가 유지된다


여유되면 사용자명,영문명 정규표현식으로 한글,영어검수한다든가ㅣ


디버그를 활용하면 브레이크포인트에서 파라미터들어온걸 확인한다든가
다 확인이되기때문에 굳이 로거로 들어왔는지 확인할필요없다
로거는 진짜 로그찍으려고 쓰는것
------------------------------

1. 프레임워크란
## 프레임워크가 무엇?
프레임워크는 개발하는 것을 도와주는 역할을 합니다.
앱이나 웹, 소프트웨어를 개발하기 위해선 굉장히 많은 노력과 시간이 듭니다. 다양한 기능을 구현하기 위해 수많은 코드를 작성해야 하죠. 그런데 프레임워크는 기본적인 기능을 갖추고 있어, 개발자가 필요한 기능을 구현하는 데만 집중할 수 있습니다. 따라서 개발하는 데 들어가는 시간과 노력을 덜어주죠.

## 간단한 비유를 하자면
저녁식사로 부대찌개를 한다고 했을 때, 우리는 재료도 사야하고, 레시피도 찾아야 하고, 직접 요리도 해야합니다.
그런데 부대찌개 밀키트가 있으면 다른 것들을 할 필요가 없이 간단히 조리만 해주면 끝입니다. 기본적인 것들은 다 갖춰져 있고 우리는 중요한 조리과정에만 집중하면 됩니다. 시간과 노력이 훨씬 절약되는 거죠. 여기서 밀키트가 프레임워크의 역할을 한다고 생각합니다.

## 프레임워크, 어떻게 탄생했을까?
개발을 하는 과정에는 공통되는 작업들이 적지 않습니다. 중복되는 작업들에 대해서는 굳이 여러번 반복할 필요가 없죠. 따라서 누군가가 미리 코드를 짜놓은 후, 누구나 쉽게 가져다 쓸수 있도록 모아놓았고 이게 프레임워크가 된것입니다.

## 비슷한 개념의 라이브러리
프레임워크와 아주 비슷한 개념으로 라이브러리가 있습니다.
라이브러리는 다른사람들이 만들어 놓은 코드를 이용할수 있게 한다는 측면에서 프레임워크와 같습니다. 
차이점은 '제어할수있는 권한'이 다릅니다.
프레임워크는 특정 틀(frame)안에서 미리 준비되어 있는 코드를 제공합니다.
학교라는 공간 안에서 학생은 학교가 만든 커리큘럼을 따라가는 것 처럼요.
반면 라이브러리는 필요할 때마다 사용자가 꺼내 쓸 수 있어요.
마치 도서관에서 읽고 싶은 책만 읽는 것 처럼요.

즉, 전체적인 흐름에 대해 제어할 수 있는 권한이 프레임워크에 있는 것과 달리,
라이브러리는 사용자가 직접 제어를 하며 필요한 기능에 대한 코드만 가져다 쓸 수 있습니다.


2. 형상관리 툴 종류 및 특징

소프트웨어의 변경사항을 체계적으로 추적하고 통제하는 것으로, 형상 관리는 일반적인 단순 버전관리 기반의 소프트웨어 운용을 좀 더 포괄적인 학술 분야의 형태로 넓히는 근간을 이야기한다.

우리가 일반적으로 아는 깃이나 svn등은 버전관리시스템이고
형상관리 개념안에 버전관리가 포함됩니다.

형상관리는 변경사항을 체계적으로 추적, 통제한다는 것. 이 말은 어떤 문서나 파일이 변경 되었을 경우 변경된 내역을 기록하였다가 나중에 이를 찾아보아야 할 경우, 변경 원인과 변경 사항을 확인해야 할 경우에 대한 관리를 말한다.

많이 쓰이는 곳은 소프트웨어 개발에서 많이 쓰이지만 꼭 이에 대해서만 쓰는 것은 아니다. 예를 들어 회사 내에서 정책 문서가 있을 경우 이에 대한 변화와 왜 변경되었는지를 기록, 추후에 동일한 변경이 필요한 경우 이에 대한 과거 변경 요인들을 확인하기 위해서도 사용한다.문서의 표지 다음, 목차보다 먼저 등장하여 변경사항을 기록하도록 하는 페이지를 많이 보았을 것이다.

소프트웨어 개발에서 많이 사용하게 된 것을 혼자 개발하는 경우에는 문서 변경과 같은 이력 조회로써 사용할 수 있지만 여러 사람이 함께 개발하는 경우 이에 대한 내역 확인이 필수이다. 버전을 확인하여 변경사항을 확인 하고 이에 대해서 반영 및 수정하는 과정이 발생한다.
또한 혼자 개발하는 경우에는 버전의 충돌이 발생하지 않지만 똑같은 파일을 다른 사람과 공유하여 개발하고 있을 경우 이에 대한 충돌 해결로도 많이 사용된다.

GitHub에서 프로그램솟가 이전 버전과 현재 버전이 어떻게 변화 되었는지 확인 할 수 있다. (적색 - 과거, 녹색 - 현재)

소프트웨어 개발에서 사용하는 형상관리 도구의 종류

CVS(Concurrent Version System)
1980년대에 만들어진 형상관리 도구로서 가장 오랫동안 사용되었으며 안정적이지만 파일관리 중 롤백이 되지 않거나 아스키코드를 지원하며 유니코드는 제한적으로 지원하고 속도가 상대적으로 느린 단점을 가지고 있다.

SVN(Subversion)
CVS의 단점을 보완하기위해 2000년에 만들어진 형상관리 도구로 중앙관리만을 지원하는 특징을 가지고 있다. change set을 커밋단위로 하여 다른 사용자의 커밋과 엉키지 않고 롤백 기능을 지원한다. 처리속도가 CVS에 비해 상대적으로 빠르다. 하지만 잦은 커밋은 리비전 번호가 크게 증가할 수 있으며 개별 이력을 관리할 수 없는 단점을 가지고 있다.

GIT
2005년 개발된 형상관리 도구로 매우 빠른 속도를 가지고 있으며 분산형 관리 시스템을 가지고 있다. 다른 형상관리 도구에 비해 다양한 기능을 지원하며 최근 가장 대중화되어 사용되고 있다. 처음 사용시 다른 도구에 비해 사용법을 숙지하는데 어려움을 가질 수 잇으나 로컬 관리와 중앙 관리가 모두 가능하여 장소에 구애받지 않고 협업을 가능케 한다.
요약.
문서나 파일이 수정 되었을 때 변경사항을 추적, 통제 하여 나중에 찾아봐야 할 때 변경 이유나 변경 사항을 확인해야 할 경우에 대한 '관리'를 말함.
Git, SVN 등이 형상관리 도구의 종류다.






CVS, SVN, Git
형상관리 툴
소스의 변화를 끊임없이 관리하는 툴
소스를 버전별로 관리할 수 있고, 실수할 경우 원복 가능하게 하는 툴

CVS

개념
GNU 라이센스
중앙에 위치한 Repository에 파일을 저장하고 모든 사용자가 접근 가능하도록 설계
checkout으로 파일 복사, commit으로 변경사항 저장
최종 버전의 소스만 관리

장점
오랫동안 사용이 되었으며 안정적
파일 전체를 저장하지 않고 변경사항만 저장하여 적은 용량 사용

단점
파일 이동이나 이름 변경은 버전 변경 미발생
버전 분기가 힘들고, 장기간 분기된 버전 운영에 대해 미설계
commit 실패 시 롤백 불가능
느린 속도
혼자 갭라할 경우 최종버전만 관리하는 CVS 툴 사용이 편리

SVN

개념
CVS와 높은 호환성을 유지하며 약간의 버그를 수정한 대체 시스템으로 개발
중앙 관리
최초 1회에 한해 파일 원본 저장, 이후에는 원본과 차이점을 저장
버전 분기가 수비고, 대규모의 분기된 프로젝트에 도움

장점
원자적 commit으로 다른 사용자의 commit과 엉키지 않으며 commit 실패 시 롤백 지원
언제든지 원하는 버전으로 복구 가능

단점
파일과 디렉토리 변경 관련 버그
불충분한 저장소 관리 명령어
CVS에 비해 상대적으로 불안정
Local Repo가 없기 때문에 자신만의 version history 관리 불가능
commit에 실수가 있을 시 다른 개발자에게 바로 영향 가능성

Git

개념
CVS를 개선하고 보다 빠른 분산 버전 제어 시스템
서버 저장소와 개발자 저장소가 독립적
사용자 기록 탐색 가능

장점
빠른 속도
분기 버전의 효율적인 운영
오프라인에서도 전체 이력 이용 가능
분산된 P2P 모델
commit 실수가 있어도 서버에 바로 영향 없음

단점
많은 기능 지원으로 높은 진입 장벽
개인 개발자에게 부적절
팀 개발을 위한 분산 환경 코딩에 최적화












