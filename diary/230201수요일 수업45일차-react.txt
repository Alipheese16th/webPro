리엑트 시작
# 1장 클래스

console.group();
이후의 메세지는 별도 메세지 그룹으로 관리됨
console.groupEnd();
메시지 그룹의 끝 종료 지정.
----------------------------
배열을 복사하려고 그대로 할당(=)하면 복사가아니라 참조주소를 같은 주소로 참조하기때문에 데이터를 수정하면 다른 한쪽도 수정된다. 복사가아님.

배열뿐만아니라 함수,객체 등도 전부 object타입이다. 즉 전부 객체
배열을 복사하려면

1번방법 (스프레드문법 이용)
var copyArray = [...memberArray];

2번방법 (Array 메소드 from 이용)
var copyArray = Array.from(memberArray);

-------------------------------
객체의 복사는 {...Object} 이런식(중괄호)으로

1번방법 (스프레드문법 이용)
var copyObject = {...memberObject}; 

2번방법 (Object 메소드 assign 이용)
var copyObject = Object.assign({},memberObject);

3번방법
var copyObject = Object.assign({id:1},memberObject);
id : 1 이라는 프로퍼티가 추가된다.

------------------------------
원래 js에서 객체를 만들고 메소드를 추가하고싶다면
객체이름의 생성자함수를 만들고, 프로토타입에 메소드를 추가한다.
그러나 ES6 버전부터 클래스를 만들수 있게되는데

### 클래스 만들기
constructor()  -- 생성자 함수 (이름 반드시 이대로)
데이터는 생성자함수에서 this로 지정
메소드는 그냥 추가 function 선언없이
sum(){//함수내용}

객체를 생성하고 다시 메소드를 수정한다든가 할수있다. 그럼 그 객체만의 메소드가 되는것.

함수의오버로딩이 없기때문에 생성자함수는 하나만 가능하다.
------------------------------
### 상속

단순히 객체를 복사해와서 사용하는것과는 다르다.
객체를 복사하면 해당 데이터 자체를 가지고 있는 것이지만
상속은 해당 데이터를 명시적으로는 확인할수없지만 분명히 가지고있는것.(프로토타입)

클래스명 뒤에 extends 붙여서 (마치 자바처럼)
생성자함수의 매개변수는 상속받은 생성자함수의 것을 전부 작성해야하고 추가로 매개변수 작성가능.
super() // 부모클래스 생성자함수

super라는 키워드는 오직 상위 생성자 함수라는 의미밖에없기때문에 생성자함수에서만 사용하는것이다. 다른 메소드에서 사용하는것이 아님.

------------------------------
### 객체 끼리의 상속 
클래스끼리만 상속할수 있는게 아니고 객체도 상속이 가능하다.

1. __proto__ 이용 (표준화 된 방법은 아니다)
예를들어 객체1은 생성자함수의 프로토타입을 전부 받아와서 해당 데이터를 사용가능하게된다.
이걸 이용해 프로토타입으로 다른 객체의 값을 가져오게하는것.
subObj.__proto__ = superObj;
superObj의 프로퍼티를 전부 받아온다.

다른 객체와 연결되어있지않고 프로토타입의 깊은복사가 되어있어서 따로 값을 가진다.

2. 함수이용
Object.create(oldObj); // oldObj를 부모로 하는 새로운 객체 생성
oldObj의 프로퍼티를 전부 가지고있지만 
깊은복사 해와서 가져온게아닌, __proto__ 로서 가지고있다. 즉, 상속.

-----------------------------
### 디폴트 매개변수

매개변수가 입력되지 않았을때 디폴트값

function sum(x=20,y=10){ // 매개변수가 들어오지않았을경우의 값: 20,10
    return x+y;
}

매개변수 = 디폴트값 문법으로 사용
-----------------------------
call, bind

### call 
this의 활용이 가능.
함수호출자를 변경할수있음.

전역객체의 함수로서 만들면 호출시 window가 실행하는 호출자이지만
함수.call(다른객체) 라고 실행시 다른객체가 이 함수를 호출한것으로 된다. 즉, this가 다른객체가 됨.

### bind
함수.bind(다른객체)
this의 대상을 바꿀수있는 함수

------------------------------
### constructor를 이용한 상속
생성자함수만으로 객체를 만드는 방식에서 사용하는방법.

상위개체의 생성자함수를
하위개체의 생성자함수에서 호출하는데 그냥 호출하면 this가 전역객체가 되어버리니까 call을 사용해서 this를 지정한다.
또한 prototype을 상위개체의 prototype으로 지정해야하는데 constructor까지 덮어씌워버리므로 생성자함수는 다시 지정해야한다.
----------------------------------
# 2장 리엑트 - 환경설정 

리엑트 프로젝트 폴더 만들 때주의점
(대문자 불가능, react 키워드 불가능)

### 리엑트 설치

 - node js 설치되어있는지 확인 
 - cmd 관리자권한에서 실행 
 - node -v
 - npm -v
 - npm install –g create-react-app   (create-react-app 설치명령어)
 - create-react-app –V
 - 리엑트 프로젝트용 소스폴더를 만들어 그 폴더의 cmd창에서 
 - create-react-app .     (api 다운로드)
 - vscode에서 폴더오픈 
 - 터미널에서 npm run start 또는 npm start   (실행)

-----
아래에는 깃헙 설명에서 볼수있는 명령어
npx create-react-app my-app
cd my-app
npm start
npx는 임시로 설치해서 사용하고 지운다. 실행할때마다 새로다운받아 쓰고지우므로 매번 새버전다운.
 my-app은 폴더이름인데 생략하고 . 로 해당폴더에 생성 가능.
-----

터미널에서 ctrl + c  // 서버 작업끝내기

### 빌드 하는법
리엑트 배포하기전에 
build 작업하는방법 (하는이유 : 배포하기전에 최소한용량을 압축하려고)
아까 실험해보던 웹사이트가 1.7메가짜리가 156kb가 된다.

터미널에서 npm run build 실행(build폴더생성)
npm install –g serve   간단한 웹서버 가능하도록(serve명령 가능하게됨)
npx serve –s build : build가 root로 함  (build폴더로 실행)

------------------------------------
# 3장 - 리엑트 컴포넌트 생성

사용자 정의 태그를 만들어주는 기술 component라고 한다. (단 컴포넌트는 첫글자 대문자, 문자마디별 대문자)
장점 : 가독성, 재사용성, 유지보수 용이성

index.html 은 index.js를 참조하고 index.js는 app.js를 참조한다.
app.js를 싹 지우고 class App extends Component{}를 만든다.
클래스 안에 render(){ return( //내용 ); } 을 구성하면 render를 실행하게되고 내용이 화면에 나오게된다.  render함수는 유사HTML을 리턴하는것.

사용자 태그(컴포넌트)를 만든다는것은 클래스를 만든다는것 
Component를 extends 상속받아서 render(){}구현 return 값 

html 문서를 조각조각내서 사용자 정의 컴포넌트에 정의하여 사용하기.
--------------------------
### props 이용 (propertys)
컴포넌트를 좀더 진화한 모습으로 만들기  (src 같은 속성을 스스로 만들어보기)
클래스 내 render안의 return안에서 {this.props.title} 이렇게 하면 해당 title속성의 값을 적용시킬수있다. 

--------------------------
컴포넌트를 파일 별로 분리하기 
import React,{Component} from 'react';
클래스명{클래스구성}
export default 파일명;   // 외부에서 사용가능 

사용할 파일에서 import 해오기
---------------------------
### State
Props : 사용자 입장에서 compoent를 사용할 때 필요한 데이터
State : props값에 따라 내부에서 구현에 필요한 데이터

생성자함수에서 this.state = {} 로 구현 



Read
Create
Update
Delete



-------------오늘 리액트 배우면서 자잘한 주의사항 --

class가 아닌 className으로 태그 클래스 지정할수있음

import 시 .js는 생략가능 .css는 생략불가

변수는 {} 중괄호로 감싸서 사용

render(){
  return(
  	하나의 태그로 감싸서 내용을 넣어야함.
  );
}

app 클래스 생성자함수 내 state를 구현해서 사용한다 
다른 컴포넌트에 전달하는건 props로 전달

해당컴포넌트의 css는 같은 폴더위치에서 같은이름으로 처리하는게 국룰

------------구글검색 
스프레드 문법 
배열이나 객체를 ...붙여서 사용하면 각 배열의값이나 객체프로퍼티가 펼쳐지게된다.  스프레드 문법은 for-of 와 같은 방식으로 내부에서 이터레이터를 사용해 요소를 수집한다.

__proto__  (prototype 관련공부좀 더)

call,bind 함수

@keyframes  애니메이션효과 주는 css



------ 복습
ctrl + J , ctrl + `  터미널오픈
"use strict"
엄격한 규칙 적용 

객체 생성시에 생성자함수의 프로토타입을 참조하여 객체에 __proto__ 속성이 생긴다. 해당 속성은 프로토타입을 참조한다는 특징이있다. 그 객체가 프로토타입의 메소드가 마음에안들어서 같은이름의메소드를 정의한다면, 프로토타입의 메소드는 더이상 참조하지않고 새로정의한 메소드를 사용하게된다. 


태그를 자바스크립트에서 element(요소)라고도 하고 리엑트에서는 컴포넌트라고 한다. 